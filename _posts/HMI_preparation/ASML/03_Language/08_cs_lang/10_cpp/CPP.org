* map iterator :
      for (INDEX_MAP::iterator i = _indexMap.begin(); i != _indexMap.end(); ++i)
      {
        output << "    <Group Index=\"" << i->first;
        // Size must be here !!! Change the schema and enable the next line !!!
        //output << "\" Size=\"" << i->second->Size;
        output << "\" Value=\"" << i->second->Value << "\"/>\r";
        delete (i->second);
      }

  II2CProtocol* protocol = dynamic_cast<II2CProtocol*>(mpc->GetProtocol());

* LibraryFactory

  class LibraryFactory
  {
  public:
    static ErrorCode Load(MpcApi::LibraryWrapper** lib);

    static ErrorCode Unload(MpcApi::LibraryWrapper* cdci);
  private:
    static MpcApi::LibraryWrapper* _libInstance;
    static int _counter;
  };

* Greater :
** desc :
template <class T> struct greater;

Function object class for greater-than inequality comparison

Binary function object class whose call returns whether the its first argument
compares greater than the second (as returned by operator >).

Generically, function objects are instances of a class with member function
operator() defined. This member function allows the object to be used with the
same syntax as a function call.

It is defined with the same behavior as:

template <class T> struct greater : binary_function <T,T,bool> {
  bool operator() (const T& x, const T& y) const {return x>y;}
};


Objects of this class can be used on standard algorithms such as sort, merge or lower_bound.

Template parameters
T
Type of the arguments to compare by the functional call.
The type shall support the operation (operator>).

Member types
member type	definition	notes
first_argument_type	T	Type of the first argument in member operator()
second_argument_type	T	Type of the second argument in member operator()
result_type	bool	Type returned by member operator()

Member functions
bool operator() (const T& x, const T& y)
Member function returning whether the first argument compares greater than the second (x>y).

** greater example
#+BEGIN_SRC c++
  #include <iostream>     // std::cout
  #include <functional>   // std::greater
  #include <algorithm>    // std::sort

  int main () {
    int numbers[]={20,40,50,10,30};
    std::sort (numbers, numbers+5, std::greater<int>());
    for (int i=0; i<5; i++)
      std::cout << numbers[i] << ' ';
    std::cout << '\n';
    return 0;
  }

#+END_SRC
*** Output:
50 40 30 20 10

* std::priority_queue
** DESC :
template <class T, class Container = vector<T>,
  class Compare = less<typename Container::value_type> > class priority_queue;

Priority queues are a type of container adaptors, specifically designed such
that its first element is always the greatest of the elements it contains,
according to some strict weak ordering criterion.

This context is similar to a heap, where elements can be inserted at any moment,
and only the max heap element can be retrieved (the one at the top in the
priority queue).

Priority queues are implemented as container adaptors, which are classes that
use an encapsulated object of a specific container class as its underlying
container, providing a specific set of member functions to access its elements.
Elements are popped from the "back" of the specific container, which is known as
the top of the priority queue.

The underlying container may be any of the standard container class templates or
some other specifically designed container class. The container shall be
accessible through random access iterators and support the following operations:

empty()
size()
front()
push_back()
pop_back()

The standard container classes vector and deque fulfill these requirements. By
default, if no container class is specified for a particular priority_queue
class instantiation, the standard container vector is used.

Support of random access iterators is required to keep a heap structure
internally at all times. This is done automatically by the container adaptor by
automatically calling the algorithm functions make_heap, push_heap and pop_heap
when needed.

Template parameters
T
Type of the elements.
Aliased as member type priority_queue::value_type.
Container
Type of the internal underlying container object where the elements are stored.
Its value_type shall be T.
Aliased as member type priority_queue::container_type.
Compare
A binary predicate that takes two elements (of type T) as arguments and returns a bool.
The expression comp(a,b), where comp is an object of this type and a and b are elements in the container, shall return true if a is considered to go before b in the strict weak ordering the function defines.
The priority_queue uses this function to maintain the elements sorted in a way that preserves heap properties (i.e., that the element popped is the last according to this strict weak ordering).
This can be a function pointer or a function object, and defaults to less<T>, which returns the same as applying the less-than operator (a<b).

Member types
C++98C++11
member type	definition	notes
value_type	The first template parameter (T)	Type of the elements
container_type	The second template parameter (Container)	Type of the underlying container
size_type	an unsigned integral type	usually the same as size_t

Member functions
(constructor)
Construct priority queue (public member function )
empty
Test whether container is empty (public member function )
size
Return size (public member function )
top
Access top element (public member function )
push
Insert element (public member function )
emplace
Construct and insert element (public member function )
pop
Remove top element (public member function )
swap
Swap contents (public member function )

** example :
#+BEGIN_SRC c++
  // make heap example
  #include <queue> // functional,iostream,ctime,cstdlib
  using namespace std;

  int main(int argc, char* argv[])
  {
      srand(time(0));
      priority_queue<int,vector<int>,greater<int> > q;
      for( int i = 0; i != 10; ++i ) q.push(rand()%10);
      cout << "Min-heap, popped one by one: ";
      while( ! q.empty() ) {
          cout << q.top() << ' ';  // 0 3 3 3 4 5 5 6 8 9
          q.pop();
      }
      cout << endl;
      return 0;
  }
  #include <queue>
  #include <iostream>

  using namespace std;

  struct comparator {
    bool operator()(int i, int j) {
      return i > j;
    }
  };

  int main(int argc, char const *argv[])
  {
    priority_queue<int, std::vector<int>, comparator> minHeap;

    minHeap.push(10);
    minHeap.push(5);
    minHeap.push(12);
    minHeap.push(3);
    minHeap.push(3);
    minHeap.push(4);

    while (!minHeap.empty()) {
      cout << minHeap.top() << " ";
      minHeap.pop();
    }
    return 0;
  }
  // 3 3 4 5 10 12

#+END_SRC
** example : push :
#+BEGIN_SRC c++
  // priority_queue::push/pop
  #include <iostream>       // std::cout
  #include <queue>          // std::priority_queue

  int main ()
  {
    std::priority_queue<int> mypq;

    mypq.push(30);
    mypq.push(100);
    mypq.push(25);
    mypq.push(40);

    std::cout << "Popping out elements...";
    while (!mypq.empty())
      {
        std::cout << ' ' << mypq.top();
        mypq.pop();
      }
    std::cout << '\n';

    return 0;
  }

  Output:
  Popping out elements... 100 40 30 25

#+END_SRC

* StringStream
// swapping ostringstream objects
#include <string>       // std::string
#include <iostream>     // std::cout
#include <sstream>      // std::stringstream

int main () {

  std::stringstream ss;

  ss << 100 << ' ' << 200;

  int foo,bar;
  ss >> foo >> bar;

  std::cout << "foo: " << foo << '\n';
  std::cout << "bar: " << bar << '\n';

  return 0;
}
* split by blank 
** ex :
#+BEGIN_SRC c++
  void split( vector<string>& result, string& str ) {
    stringstream ss( str );
    string temp;
    while ( getline( ss, temp, ' ' ) )
      result.push_back( temp );
  }
#+END_SRC

* std::next_permutation
** desc :
default (1)	
template <class BidirectionalIterator>
  bool next_permutation (BidirectionalIterator first,
                         BidirectionalIterator last);
custom (2)	
template <class BidirectionalIterator, class Compare>
  bool next_permutation (BidirectionalIterator first,
                         BidirectionalIterator last, Compare comp);

Transform range to next permutation

Rearranges the elements in the range [first,last) into the next lexicographically greater permutation.

A permutation is each one of the N! possible arrangements the elements can take
(where N is the number of elements in the range). Different permutations can be
ordered according to how they compare lexicographicaly to each other; The first
such-sorted possible permutation (the one that would compare lexicographically
smaller to all other permutations) is the one which has all its elements sorted
in ascending order, and the largest has all its elements sorted in descending
order.

The comparisons of individual elements are performed using either operator< for
the first version, or comp for the second.

If the function can determine the next higher permutation, it rearranges the
elements as such and returns true. If that was not possible (because it is
already at the largest possible permutation), it rearranges the elements
according to the first permutation (sorted in ascending order) and returns
false.

Parameters

first, last

Bidirectional iterators to the initial and final positions of the sequence. The range used is [first,last), which contains all the elements between first and last, including the element pointed by first but not the element pointed by last.

BidirectionalIterator shall point to a type for which swap is properly defined.
comp
Binary function that accepts two arguments of the type pointed by BidirectionalIterator, and returns a value convertible to bool. The value returned indicates whether the first argument is considered to go before the second in the specific strict weak ordering it defines.
The function shall not modify any of its arguments.
This can either be a function pointer or a function object.

Return value
true if the function could rearrange the object as a lexicographicaly greater permutation.
Otherwise, the function returns false to indicate that the arrangement is not greater than the previous, but the lowest possible (sorted in ascending order).

** code :
#+BEGIN_SRC c++
// next_permutation example
#include <iostream>     // std::cout
#include <algorithm>    // std::next_permutation, std::sort

int main () {
  int myints[] = {1,2,3};

  std::sort (myints,myints+3);

  std::cout << "The 3! possible permutations with 3 elements:\n";
  do {
    std::cout << myints[0] << ' ' << myints[1] << ' ' << myints[2] << '\n';
  } while ( std::next_permutation(myints,myints+3) );

  std::cout << "After loop: " << myints[0] << ' ' << myints[1] << ' ' << myints[2] << '\n';

  return 0;
}

#+END_SRC
** Output:
The 3! possible permutations with 3 elements:
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
After loop: 1 2 3

* tutorial point :
http://www.tutorialspoint.com/cplusplus/cpp_interfaces.htm


** ex :
#+BEGIN_SRC c++
  #include <iostream>
  #include <cstring>

  using namespace std;
  void printBook( struct Books *book );

  struct Books
  {
     char  title[50];
     char  author[50];
     char  subject[100];
     int   book_id;
  };

  int main( )
  {
     struct Books Book1;        // Declare Book1 of type Book
     struct Books Book2;        // Declare Book2 of type Book

     // Book 1 specification
     strcpy( Book1.title, "Learn C++ Programming");
     strcpy( Book1.author, "Chand Miyan");
     strcpy( Book1.subject, "C++ Programming");
     Book1.book_id = 6495407;

     // Book 2 specification
     strcpy( Book2.title, "Telecom Billing");
     strcpy( Book2.author, "Yakit Singha");
     strcpy( Book2.subject, "Telecom");
     Book2.book_id = 6495700;

     // Print Book1 info, passing address of structure
     printBook( &Book1 );

     // Print Book1 info, passing address of structure
     printBook( &Book2 );

     return 0;
  }
  // This function accept pointer to structure as parameter.
  void printBook( struct Books *book )
  {
     cout << "Book title : " << book->title <<endl;
     cout << "Book author : " << book->author <<endl;
     cout << "Book subject : " << book->subject <<endl;
     cout << "Book id : " << book->book_id <<endl;
  }
#+END_SRC

** friend :
#+BEGIN_SRC c++
  #include <iostream>

  using namespace std;

  class Box
  {
    double width;
  public:
    friend void printWidth( Box box );
    void setWidth( double wid );
  };

  // Member function definition
  void Box::setWidth( double wid )
  {
    width = wid;
  }

  // Note: printWidth() is not a member function of any class.
  void printWidth( Box box )
  {
    /* Because printWidth() is a friend of Box, it can
       directly access any member of this class */
    cout << "Width of box : " << box.width <<endl;
  }

  // Main function for the program
  int main( )
  {
    Box box;

    // set box width with member function
    box.setWidth(10.0);

    // Use friend function to print the wdith.
    printWidth( box );

    return 0;
  }
#+END_SRC


** interface :
An interface describes the behavior or capabilities of a C++ class without committing to a particular implementation of that class.

The C++ interfaces are implemented using abstract classes and these abstract classes should not be confused with data abstraction which is a concept of keeping implementation details separate from associated data.

A class is made abstract by declaring at least one of its functions as pure virtual function. A pure virtual function is specified by placing "= 0" in its declaration as follows:

class Box
{
   public:
      // pure virtual function
      virtual double getVolume() = 0;
   private:
      double length;      // Length of a box
      double breadth;     // Breadth of a box
      double height;      // Height of a box
};
The purpose of an abstract class (often referred to as an ABC) is to provide an appropriate base class from which other classes can inherit. Abstract classes cannot be used to instantiate objects and serves only as an interface. Attempting to instantiate an object of an abstract class causes a compilation error.

Thus, if a subclass of an ABC needs to be instantiated, it has to implement each of the virtual functions, which means that it supports the interface declared by the ABC. Failure to override a pure virtual function in a derived class, then attempting to instantiate objects of that class, is a compilation error.

Classes that can be used to instantiate objects are called concrete classes.

Abstract Class Example:
Consider the following example where parent class provides an interface to the base class to implement a function called getArea():

#include <iostream>
 
using namespace std;
 
// Base class
class Shape 
{
public:
   // pure virtual function providing interface framework.
   virtual int getArea() = 0;
   void setWidth(int w)
   {
      width = w;
   }
   void setHeight(int h)
   {
      height = h;
   }
protected:
   int width;
   int height;
};
 
// Derived classes
class Rectangle: public Shape
{
public:
   int getArea()
   { 
      return (width * height); 
   }
};
class Triangle: public Shape
{
public:
   int getArea()
   { 
      return (width * height)/2; 
   }
};
 
int main(void)
{
   Rectangle Rect;
   Triangle  Tri;
 
   Rect.setWidth(5);
   Rect.setHeight(7);
   // Print the area of the object.
   cout << "Total Rectangle area: " << Rect.getArea() << endl;

   Tri.setWidth(5);
   Tri.setHeight(7);
   // Print the area of the object.
   cout << "Total Triangle area: " << Tri.getArea() << endl; 

   return 0;
}
When the above code is compiled and executed, it produces the following result:

Total Rectangle area: 35
Total Triangle area: 17
You can see how an abstract class defined an interface in terms of getArea() and two other classes implemented same function but with different algorithm to calculate the area specific to the shape.

Designing Strategy:
An object-oriented system might use an abstract base class to provide a common and standardized interface appropriate for all the external applications. Then, through inheritance from that abstract base class, derived classes are formed that all operate similarly.

The capabilities (i.e., the public functions) offered by the external applications are provided as pure virtual functions in the abstract base class. The implementations of these pure virtual functions are provided in the derived classes that correspond to the specific types of the application.

This architecture also allows new applications to be added to a system easily, even after the system has been defined.

** encapsulated :
All C++ programs are composed of the following two fundamental elements:

Program statements (code): This is the part of a program that performs actions and they are called functions.

Program data: The data is the information of the program which affected by the program functions.

Encapsulation is an Object Oriented Programming concept that binds together the data and functions that manipulate the data, and that keeps both safe from outside interference and misuse. Data encapsulation led to the important OOP concept of data hiding.

Data encapsulation is a mechanism of bundling the data, and the functions that use them and data abstraction is a mechanism of exposing only the interfaces and hiding the implementation details from the user.

C++ supports the properties of encapsulation and data hiding through the creation of user-defined types, called classes. We already have studied that a class can contain private, protected and public members. By default, all items defined in a class are private. For example:

class Box
{
   public:
      double getVolume(void)
      {
         return length * breadth * height;
      }
   private:
      double length;      // Length of a box
      double breadth;     // Breadth of a box
      double height;      // Height of a box
};
The variables length, breadth, and height are private. This means that they can be accessed only by other members of the Box class, and not by any other part of your program. This is one way encapsulation is achieved.

To make parts of a class public (i.e., accessible to other parts of your program), you must declare them after the public keyword. All variables or functions defined after the public specifier are accessible by all other functions in your program.

Making one class a friend of another exposes the implementation details and reduces encapsulation. The ideal is to keep as many of the details of each class hidden from all other classes as possible.

Data Encapsulation Example:
Any C++ program where you implement a class with public and private members is an example of data encapsulation and data abstraction. Consider the following example:

#include <iostream>
using namespace std;

class Adder{
   public:
      // constructor
      Adder(int i = 0)
      {
        total = i;
      }
      // interface to outside world
      void addNum(int number)
      {
          total += number;
      }
      // interface to outside world
      int getTotal()
      {
          return total;
      };
   private:
      // hidden data from outside world
      int total;
};
int main( )
{
   Adder a;
   
   a.addNum(10);
   a.addNum(20);
   a.addNum(30);

   cout << "Total " << a.getTotal() <<endl;
   return 0;
}
When the above code is compiled and executed, it produces the following result:

Total 60
Above class adds numbers together, and returns the sum. The public members addNum and getTotal are the interfaces to the outside world and a user needs to know them to use the class. The private member total is something that is hidden from the outside world, but is needed for the class to operate properly.

Designing Strategy:
Most of us have learned through bitter experience to make class members private by default unless we really need to expose them. That's just good encapsulation.

This wisdom is applied most frequently to data members, but it applies equally to all members, including virtual functions.

** Data abstraction :
Data abstraction refers to, providing only essential information to the outside world and hiding their background details, i.e., to represent the needed information in program without presenting the details.

Data abstraction is a programming (and design) technique that relies on the separation of interface and implementation.

Let's take one real life example of a TV, which you can turn on and off, change the channel, adjust the volume, and add external components such as speakers, VCRs, and DVD players, BUT you do not know its internal details, that is, you do not know how it receives signals over the air or through a cable, how it translates them, and finally displays them on the screen.

Thus, we can say a television clearly separates its internal implementation from its external interface and you can play with its interfaces like the power button, channel changer, and volume control without having zero knowledge of its internals.

Now, if we talk in terms of C++ Programming, C++ classes provides great level of data abstraction. They provide sufficient public methods to the outside world to play with the functionality of the object and to manipulate object data, i.e., state without actually knowing how class has been implemented internally.

For example, your program can make a call to the sort() function without knowing what algorithm the function actually uses to sort the given values. In fact, the underlying implementation of the sorting functionality could change between releases of the library, and as long as the interface stays the same, your function call will still work.

In C++, we use classes to define our own abstract data types (ADT). You can use the cout object of class ostream to stream data to standard output like this:

#include <iostream>
using namespace std;

int main( )
{
   cout << "Hello C++" <<endl;
   return 0;
}
Here, you don't need to understand how cout displays the text on the user's screen. You need to only know the public interface and the underlying implementation of cout is free to change.

Access Labels Enforce Abstraction:
In C++, we use access labels to define the abstract interface to the class. A class may contain zero or more access labels:

Members defined with a public label are accessible to all parts of the program. The data-abstraction view of a type is defined by its public members.

Members defined with a private label are not accessible to code that uses the class. The private sections hide the implementation from code that uses the type.

There are no restrictions on how often an access label may appear. Each access label specifies the access level of the succeeding member definitions. The specified access level remains in effect until the next access label is encountered or the closing right brace of the class body is seen.

Benefits of Data Abstraction:
Data abstraction provides two important advantages:

Class internals are protected from inadvertent user-level errors, which might corrupt the state of the object.

The class implementation may evolve over time in response to changing requirements or bug reports without requiring change in user-level code.

By defining data members only in the private section of the class, the class author is free to make changes in the data. If the implementation changes, only the class code needs to be examined to see what affect the change may have. If data are public, then any function that directly accesses the data members of the old representation might be broken.

Data Abstraction Example:
Any C++ program where you implement a class with public and private members is an example of data abstraction. Consider the following example:

#include <iostream>
using namespace std;

class Adder{
   public:
      // constructor
      Adder(int i = 0)
      {
        total = i;
      }
      // interface to outside world
      void addNum(int number)
      {
          total += number;
      }
      // interface to outside world
      int getTotal()
      {
          return total;
      };
   private:
      // hidden data from outside world
      int total;
};
int main( )
{
   Adder a;
   
   a.addNum(10);
   a.addNum(20);
   a.addNum(30);

   cout << "Total " << a.getTotal() <<endl;
   return 0;
}
When the above code is compiled and executed, it produces the following result:

Total 60
Above class adds numbers together, and returns the sum. The public members addNum and getTotal are the interfaces to the outside world and a user needs to know them to use the class. The private member total is something that the user doesn't need to know about, but is needed for the class to operate properly.

Designing Strategy:
Abstraction separates code into interface and implementation. So while designing your component, you must keep interface independent of the implementation so that if you change underlying implementation then interface would remain intact.

In this case whatever programs are using these interfaces, they would not be impacted and would just need a recompilation with the latest implementation.

* lower_bound :
std::lower_bound
default (1)	
template <class ForwardIterator, class T>
  ForwardIterator lower_bound (ForwardIterator first, ForwardIterator last,
                               const T& val);
custom (2)	
template <class ForwardIterator, class T, class Compare>
  ForwardIterator lower_bound (ForwardIterator first, ForwardIterator last,
                               const T& val, Compare comp);
Return iterator to lower bound

Returns an iterator pointing to the first element in the range [first,last) _which does not compare less than val._

The elements are compared using operator< for the first version, and comp for
the second. The elements in the range shall already be sorted according to this
same criterion (operator< or comp), or at least partitioned with respect to val.

The function optimizes the number of comparisons performed by comparing
non-consecutive elements of the sorted range, which is specially efficient for
random-access iterators.

Unlike upper_bound, the value pointed by the iterator returned by this function
may also be equivalent to val, and not only greater.

The behavior of this function template is equivalent to:
#+BEGIN_SRC c++
  template <class ForwardIterator, class T>
    ForwardIterator lower_bound (ForwardIterator first, ForwardIterator last, const T& val)
  {
    ForwardIterator it;
    iterator_traits<ForwardIterator>::difference_type count, step;
    count = distance(first,last);
    while (count>0)
    {
      it = first; step=count/2; advance (it,step);
      if (*it<val) {                 // or: if (comp(*it,val)), for version (2)
        first=++it;
        count-=step+1;
      }
      else count=step;
    }
    return first;
  }

#+END_SRC


Parameters
first, last
Forward iterators to the initial and final positions of a sorted (or properly partitioned) sequence. The range used is [first,last), which contains all the elements between first and last, including the element pointed by first but not the element pointed by last.
val
Value of the lower bound to search for in the range.
For (1), T shall be a type supporting being compared with elements of the range [first,last) as the right-hand side operand of operator<.
comp
Binary function that accepts two arguments (the first of the type pointed by ForwardIterator, and the second, always val), and returns a value convertible to bool. The value returned indicates whether the first argument is considered to go before the second.
The function shall not modify any of its arguments.
This can either be a function pointer or a function object.

Return value
An iterator to the lower bound of val in the range.
If all the element in the range compare less than val, the function returns last.

*** Example
#+BEGIN_SRC c++
  // lower_bound/upper_bound example
  #include <iostream>     // std::cout
  #include <algorithm>    // std::lower_bound, std::upper_bound, std::sort
  #include <vector>       // std::vector

  int main () {
    int myints[] = {10,20,30,30,20,10,10,20};
    std::vector<int> v(myints,myints+8);           // 10 20 30 30 20 10 10 20

    std::sort (v.begin(), v.end());                // 10 10 10 20 20 20 30 30

    std::vector<int>::iterator low,up;
    low=std::lower_bound (v.begin(), v.end(), 20); //          ^
    up= std::upper_bound (v.begin(), v.end(), 20); //                   ^

    std::cout << "lower_bound at position " << (low- v.begin()) << '\n';
    std::cout << "upper_bound at position " << (up - v.begin()) << '\n';

    return 0;
  }

#+END_SRC
Edit & Run


Output:
lower_bound at position 3
upper_bound at position 6


* upper_bound :

#+BEGIN_SRC c++
default (1)	
template <class ForwardIterator, class T>
  ForwardIterator upper_bound (ForwardIterator first, ForwardIterator last,
                               const T& val);
custom (2)	
template <class ForwardIterator, class T, class Compare>
  ForwardIterator upper_bound (ForwardIterator first, ForwardIterator last,
                               const T& val, Compare comp);

#+END_SRC
Return iterator to upper bound

Returns an iterator pointing to the first element in the range [first,last) _which compares greater than val._

The elements are compared using operator< for the first version, and comp for
the second. The elements in the range shall already be sorted according to this
same criterion (operator< or comp), or at least partitioned with respect to val.

The function optimizes the number of comparisons performed by comparing
non-consecutive elements of the sorted range, which is specially efficient for
random-access iterators.

Unlike lower_bound, the value pointed by the iterator returned by this function
cannot be equivalent to val, only greater.

The behavior of this function template is equivalent to:
#+BEGIN_SRC c++
  template <class ForwardIterator, class T>
    ForwardIterator upper_bound (ForwardIterator first, ForwardIterator last, const T& val)
  {
    ForwardIterator it;
    iterator_traits<ForwardIterator>::difference_type count, step;
    count = std::distance(first,last);
    while (count>0)
    {
      it = first; step=count/2; std::advance (it,step);
      if (!(val<*it))                 // or: if (!comp(val,*it)), for version (2)
        { first=++it; count-=step+1;  }
      else count=step;
    }
    return first;
  }

#+END_SRC


Parameters
first, last
Forward iterators to the initial and final positions of a sorted (or properly partitioned) sequence. The range used is [first,last), which contains all the elements between first and last, including the element pointed by first but not the element pointed by last.
val
Value of the upper bound to search for in the range.
For (1), T shall be a type supporting being compared with elements of the range [first,last) as the left-hand side operand of operator<.
comp
Binary function that accepts two arguments (the first is always val, and the second of the type pointed by ForwardIterator), and returns a value convertible to bool. The value returned indicates whether the first argument is considered to go before the second.
The function shall not modify any of its arguments.
This can either be a function pointer or a function object.

Return value
An iterator to the upper bound position for val in the range.
If no element in the range compares greater than val, the function returns last.

#+BEGIN_SRC c++
  // lower_bound/upper_bound example
  #include <iostream>     // std::cout
  #include <algorithm>    // std::lower_bound, std::upper_bound, std::sort
  #include <vector>       // std::vector

  int main () {
    int myints[] = {10,20,30,30,20,10,10,20};
    std::vector<int> v(myints,myints+8);           // 10 20 30 30 20 10 10 20

    std::sort (v.begin(), v.end());                // 10 10 10 20 20 20 30 30

    std::vector<int>::iterator low,up;
    low=std::lower_bound (v.begin(), v.end(), 20); //          ^
    up= std::upper_bound (v.begin(), v.end(), 20); //                   ^

    std::cout << "lower_bound at position " << (low- v.begin()) << '\n';
    std::cout << "upper_bound at position " << (up - v.begin()) << '\n';

    return 0;
  }

#+END_SRC
** Edit & Run


Output:
lower_bound at position 3
upper_bound at position 6

* std::string::find_first_not_of

C++98C++11
string (1)	
size_t find_first_not_of (const string& str, size_t pos = 0) const;
c-string (2)	
size_t find_first_not_of (const char* s, size_t pos = 0) const;
buffer (3)	
size_t find_first_not_of (const char* s, size_t pos, size_t n) const;
character (4)	
size_t find_first_not_of (char c, size_t pos = 0) const;

Find absence of character in string
_Searches the string for the first character that does not match any of the characters specified in its arguments._

When pos is specified, the search only includes characters at or after position pos, ignoring any possible occurrences before that character.

Parameters
str
Another string with the set of characters to be used in the search.
pos
Position of the first character in the string to be considered in the search.
If this is greater than the string length, the function never finds matches.
Note: The first character is denoted by a value of 0 (not 1): A value of 0 means that the entire string is searched.
s
Pointer to an array of characters.
If argument n is specified (3), the first n characters in the array are used in the search.
Otherwise (2), a null-terminated sequence is expected: the length of the sequence with the characters used in the search is determined by the first occurrence of a null character.
n
Number of character values to search for.
c
Individual character to be searched for.

size_t is an unsigned integral type (the same as member type string::size_type).

Return Value
The position of the first character that does not match.
If no such characters are found, the function returns string::npos.

size_t is an unsigned integral type (the same as member type string::size_type).

** code :
#+BEGIN_SRC c++
  // string::find_first_not_of
  #include <iostream>       // std::cout
  #include <string>         // std::string
  #include <cstddef>        // std::size_t

  int main ()
  {
    std::string str ("look for non-alphabetic characters...");

    std::size_t found = str.find_first_not_of("abcdefghijklmnopqrstuvwxyz ");

    if (found!=std::string::npos)
    {
      std::cout << "The first non-alphabetic character is " << str[found];
      std::cout << " at position " << found << '\n';
    }

    return 0;
  }

#+END_SRC

The first non-alphabetic character is - at position 12


* std::string::erase
C++98C++11
sequence (1)	
 string& erase (size_t pos = 0, size_t len = npos);
character (2)	
iterator erase (iterator p);
range (3)	
     iterator erase (iterator first, iterator last);

Erase characters from string

Erases part of the string, reducing its length:

(1) sequence
Erases the portion of the string value that begins at the character position pos and spans len characters (or until the end of the string, if either the content is too short or if len is string::npos.
Notice that the default argument erases all characters in the string (like member function clear).
(2) character
Erases the character pointed by p.
(3) range
Erases the sequence of characters in the range [first,last).

Parameters
pos
Position of the first character to be erased.
If this is greater than the string length, it throws out_of_range.
Note: The first character in str is denoted by a value of 0 (not 1).
len
Number of characters to erase (if the string is shorter, as many characters as possible are erased).
A value of string::npos indicates all characters until the end of the string.
p
Iterator to the character to be removed.
first, last
Iterators specifying a range within the string] to be removed: [first,last). i.e., the range includes all the characters between first and last, including the character pointed by first but not the one pointed by last.


size_t is an unsigned integral type (the same as member type string::size_type).
Member types iterator and const_iterator are random access iterator types that point to characters of the string.

Return value
The sequence version (1) returns *this.
The others return an iterator referring to the character that now occupies the position of the first character erased, or string::end if no such character exists.

Member type iterator is a random access iterator type that points to characters of the string.
** code :
#+BEGIN_SRC c++
  // string::erase
  #include <iostream>
  #include <string>

  int main ()
  {
    std::string str ("This is an example sentence.");
    std::cout << str << '\n';
                                             // "This is an example sentence."
    str.erase (10,8);                        //            ^^^^^^^^
    std::cout << str << '\n';
                                             // "This is an sentence."
    str.erase (str.begin()+9);               //           ^
    std::cout << str << '\n';
                                             // "This is a sentence."
    str.erase (str.begin()+5, str.end()-9);  //       ^^^^^
    std::cout << str << '\n';
                                             // "This sentence."
    return 0;
  }

#+END_SRC
** Edit & Run

Output:
This is an example sentence.
This is an sentence.
This is a sentence.
This sentence.

* getline 

** code :
#+BEGIN_SRC c++
  // stringstream example
  int main() {
    // inputs
    std::string str("abc:def");
    char split_char = ':';

    // work
    std::istringstream split(str);
    std::vector<std::string> tokens;
    for (std::string each; std::getline(split, each, split_char); tokens.push_back(each))
      ;

    // now use `tokens`
  }

#+END_SRC

* std::shared_ptr
template <class T> class shared_ptr;
Shared pointer
Manages the storage of a pointer, providing a limited garbage-collection
facility, possibly sharing that management with other objects.

Objects of shared_ptr types have the ability of taking ownership of a pointer
and share that ownership: once they take ownership, the group of owners of a
pointer become responsible for its deletion when the last one of them releases
that ownership.

shared_ptr objects release ownership on the object they co-own as soon as they
themselves are destroyed, or as soon as their value changes either by an
assignment operation or by an explicit call to shared_ptr::reset. Once all
shared_ptr objects that share ownership over a pointer have released this
ownership, the managed object is deleted (normally by calling ::delete, but a
different deleter may be specified on construction).

shared_ptr objects can only share ownership by copying their value: If two
shared_ptr are constructed (or made) from the same (non-shared_ptr) pointer,
they will both be owning the pointer without sharing it, causing potential
access problems when one of them releases it (deleting its managed object) and
leaving the other pointing to an invalid location.

Additionally, shared_ptr objects can share ownership over a pointer while at the
same time pointing to another object. This ability is known as aliasing (see
constructors), and is commonly used to point to member objects while owning the
object they belong to. Because of this, a shared_ptr may relate to two pointers:

A stored pointer, which is the pointer it is said to point to, and the one it
dereferences with operator*.

An owned pointer (possibly shared), which is the pointer the ownership group is
in charge of deleting at some point, and for which it counts as a use.

Generally, the stored pointer and the owned pointer refer to the same object,
but alias shared_ptr objects (those constructed with the alias constructor and
their copies) may refer to different objects.

A shared_ptr that does not own any pointer is called an empty shared_ptr. A
shared_ptr that points to no object is called a null shared_ptr and shall not be
dereferenced. Notice though that an empty shared_ptr is not necessarily a null
shared_ptr, and a null shared_ptr is not necessarily an empty shared_ptr.

shared_ptr objects replicate a limited pointer functionality by providing access
to the object they point to through operators * and ->. For safety reasons, they
do not support pointer arithmetics.

A related class, weak_ptr, is able to share pointers with shared_ptr objects
without owning them.

Template parameters T The type of the managed object, aliased as member type
element_type.

Member types The following alias is a member type of shared_ptr.

* 避免 memory leak：C++11 Smart Pointer（上）
2012/03/03 

之前 Heresy 已經有介紹過 C++ 的新標準、C++11 了～而更早之前，Heresy 也有針對
Visual C++ 10 所支援的 C++0x Core Language 的新功能，做了一些介紹，有興趣的可以
回去參考《C++ 語法再加強：C++0x》一文。而這一篇呢，則是來講一下 C++11 裡、STL 裡
的新東西：「General-purpose Smart Pointers」～

所謂「Smart Pointer」是幹嘛的呢？基本上，他是一種用來模擬傳統的 pointer、提供一
些附加功能的特殊資料型別；比較常見的功能，主要就是透過自動資源回收（automatic
garbage collection）的機制、來進行記憶體管理了～

Memory Leak

為什麼要做這件事呢？主要一點，就是 C++ 有提供用 new 和 delete 這種動態記憶體配置
的方法，可以很自由地配置、使用程式需要的記憶體。但是在使用 new 來配置記憶體的時
候，是需要非常小心的！因為他所配置出來的記憶體空間，不像一般的變數一樣，會在生命
周期結束的時候自動把資源釋放掉，除非自己使用 delete 來釋放，不然到程式結束之前，
記憶體空間都會一直佔在那邊。

而如果 new 出來了之後、在沒有指標去指到那塊記憶體空間、又沒有做對應的 delete 的
情況下，就會產生「記憶體還是佔在那邊，但是卻沒有辦法使用、也沒辦法釋放」的問題，
也就是所謂的「memory leak」（維基百科）。

例如下面就是一個 memory leak 的例子：
void MemoryAlloc()
{
  int* a = new int(0);
}
當呼叫 MemoryAlloc() 這個函式的時候，在函式內部就會動態配置一塊記憶體空間，透過
a 這個指標拿來使用。但是在函式結束後，a 這個指標就因為生命週期的關係而自動消失、
無法再使用了，但是他所指到的記憶體空間，卻還是佔在那邊！此時由於已經沒有指標指到
那塊記憶體空間了，所以不但沒辦法使用那塊記憶體空間、連要釋放掉都釋放不了…

當然，這個狀況其實很好解，只要在 MemoryAlloc() 裡，記得加上一行 delete a; 就可以
了，但是有的時候卻沒有那麼簡單。例如，當一個函式會回傳一個 pointer 的時候，其實
有的時候會很難判斷到底要由誰來做 delete 的動作…下面是一個例子：

class DataGenerator
{
public:
  int* GetData();
};

在 DataGenerator 裡，有一個成員函式 int* GetData()，會傳出來一個 int 的指標；看
起來好像沒有什麼大問題？但是在使用的時候，卻有一個問題，那就是到底應不應該在外不
去釋放這個指標所指到的記憶體空間？例如下面這樣的程式，就會是一個例子：

DataGenerator DataGen;
int* A = DataGen.GetData();
delete A; // Should do this?

因為實際上，除非文件有很明確地說明這個函式所回傳的記憶體空間不會在 DataGenerator
內部再被用到、需要在外部做釋放，不然其實在外部用 delete 去釋放這塊記憶體空間，其
實是很危險的一件事…因為搞不好在外面把他釋放掉後，裡面又跑去使用這塊已經被釋放的
記憶體空間，這時候程式就會出問題了。

此外，也還有很多狀況，都有可能會產生「不確定該在哪邊 delete」的問題；例如有多個
指標都只到同一塊記憶體空間的時候，也有可能會很難確認到底什麼時候該 delete 他。

 
C++11 的 Smart Pointer

而為了要解決這類的問題，C++ 就在 STL 裡面，引進了「Smart Point」的概念（註 1），
用來取代指標做的動態配置的資源管理。在 C++11 的 STL 裡，針對使用需求的不同，提供
了三種不同的 Smart Pointer，分別是：

** unique_ptr [MSDN]
確保一份資源（被配置出來的記憶體空間）只會被一個 unique_ptr 物件管理的 smart
pointer；當 unique_ptr 物件消失時，就會自動釋放資源。

** shared_ptr [MSDN]

可以有多個 shared_ptr 共用一份資源的 smart pointer，內部會記錄這份資源被使用的次
數（reference counter），只要還有 shared_ptr 物件的存在、資源就不會釋放；只有當
所有使用這份資源的 shared_ptr 物件都消失的時候，資源才會被自動釋放。

** weak_ptr [MSDN]
搭配 shared_ptr 使用的 smart pointer，和 shared_ptr 的不同點在於 weak_ptr 不會影
響資源被使用的次數，也就是說的 weak_ptr 存在與否不代表資源會不會被釋放掉，

這些 smart pointer 都是 template class 的形式，所以適用範圍很廣泛；他們都是被定
義在 <memory> 這個 header 檔裡、在 std 這個 namespace 下，如果要使用的話，要記得
include 這個 header 檔。以 Microsoft Visual C++ 來說，在 VC2010（VC10）就已經都
有支援（MSDN，VC11 的說明感覺寫的比較好），可以直接用了～（註 2）

而他們的使用也都相當簡單，基本上只有在宣告的時候要稍微改一下，其他使用方法都是幾
乎不用改變的～這些 smart pointer 都有定義 operator* 和 operator->，所以可以把他
們當作一般的 pointer 來操作。例如一般的 pointer 大概會是這樣使用：

#+BEGIN_SRC c++
int* a = new int(0);  // allocate memory
int b = *a;           // dereference
delete a;             // release resource

#+END_SRC

而使用 smart pointer 的話，則會變成是：

#+BEGIN_SRC c++
unique_ptr<int> a( new int(0) );
int b = *a;
#+END_SRC

基本上，就是宣告的方法要做修改，同時也不需要特別去 delete 而已。

而如果是 class 的成員函式的話，基本上改用 smart pointer 的時候，使用方法基本上也
是不需要改變的。例如下面是一般的 pointer 的寫法：

#+BEGIN_SRC c++
  vector<int>* pVec = new vector<int>();
  pVec->push_back( 1 );
  cout << pVec->size() << endl;
  delete pVec;
#+END_SRC
下面則是改用 unique_ptr 的寫法：
#+BEGIN_SRC c++
unique_ptr< vector<int> > pVec( new vector<int>() );
pVec->push_back( 1 );
cout << pVec->size() << endl;
#+END_SRC
基本上，在使用上也是一樣，除了宣告和初始化的方法不一樣外，使用上不太需要修改什麼
就可以直接用了～如果真的有需要，也可以透過 get() 這個函式來取得本來的指標來進行
操作，不過這樣就有點失去使用 smart pointer 的目的就是了。

而如果是要把函式內動態配置的資源傳出來的話，使用 smart pointer 也就不用考慮到該
由誰來 delete 的問題，而可以丟給 smart pointer 自己去管理了～

#+BEGIN_SRC c++
shared_ptr<int> MemoryAlloc()
{
  shared_ptr<int> a( new int(0) );
 
  return a;
}

#+END_SRC

由於這些 smart pointer 會做一定程度的自動資源管理，不用像本來使用動態記憶體配置
的時候，要去刻意透過 delete 來做記憶體空間的釋放，所以在使用 smart pointer 的時
候，可以用比較簡單的方法，來避免 memory leak、或是不知道該由誰來釋放記憶體空間的
問題了～
 
簡介大概就這樣，下一篇，就比較詳細地來介紹一下這三種 smart pointer 吧～
註解：

實際上，Smart Pointer 的概念並不是 C++11 才有的，在之前的 C++ STL 裡，其實也已經
有提供 auto_ptr 可以使用（參考），不過在 C++11 是建議用 unique_ptr 來取代
auto_ptr；原因可以參考《Using unique_ptr, Part I》這篇文章。

如t果使用的開發環境所提供的 STL 裡沒有提供 C++11 新的 Smart Pointer 的話，也可以
使用 C++ Boost Libraries 所提供的版本，基本上功能應該算是完全相同的，不過還有更
多類型。


* 避免 memory leak：C++11 Smart Pointer（下）

延續前一篇的簡介，接下來繼續來講一下 C++ 11 提供的三種 smart pointer 的細節吧。

這部分，除了維基百科上已經有一定程度的說明外，建議也可以參考 MSDN 上針對 VC11 寫
的《Smart Pointers (Modern C++)》這篇文章，裡面也有針對 unique_ptr、shared_ptr、
weak_ptr 這三者做進一步的說明：

How to: Create and Use unique_ptr Instances
How to: Create and Use shared_ptr Instances
How to: Create and Use weak_ptr Instances

下面則是 Heresy 自己整理的內容：

** unique_ptr
首先，是使用上最單純、限制比較多的 unique_ptr。他是在 C++11 裡，用來取代之前的
auto_ptr 的（請參考前一篇的註 1）。他的基本設計概念，就是一塊記憶體空間只會被一
個 unique_ptr 物件擁有，而不能有多個 unique_ptr 物件共用一塊記憶體空間；而當
unique_ptr 物件消失時，他所擁有的記憶體空間也就會自動被釋放掉。

像以前面 MemoryAlloc() 的例子來說，在函式結束後，所配置出來的記憶體空間會因為沒
有 delete 掉，而持續佔在那裏；但是如果改用 unique_ptr 來做的話，就會變成：

#+BEGIN_SRC c++
void MemoryAlloc()
{
  unique_ptr<int> a( new int(0) );
}
#+END_SRC

如果這樣寫的話，在 MemoryAlloc() 結束的時候，a 就會消失、而所配置出來的記憶體空

間也會跟著被釋放，也因此就不會有 memory leak 的問題。

而由於 unique_ptr 需要確保一份資源只被一個 unique_ptr 擁有，所以他有不可複製的特
性，所以像下面的程式碼，是會無法編譯的～

#+BEGIN_SRC c++
unique_ptr<int> a( new int(0) );
unique_ptr<int> b = a;  // compile error!
#+END_SRC
不過，如果有需要的話，也可以透過 STL 的 std::move() 這個函式，把資源的所有權轉移
給別的 unique_ptr 物件，其用法如下：

#+BEGIN_SRC c++
unique_ptr<int> a( new int(0) );
unique_ptr<int> b = move( a );
#+END_SRC

要注意的是，在轉移所有權後，本來的 unique_ptr 物件（這邊是 a）就不再有這份資源的
所有權、也無法再透過它來存取這份資源了！

而如果要把在函式內配置的記憶體空間傳出來的話，也是可以的，只要寫成下面這樣就可以了：

#+BEGIN_SRC c++
unique_ptr<int> MemoryAlloc()
{
  unique_ptr<int> a( new int(0) );
 
  return a;
}
#+END_SRC

這樣的寫法，在把 a 回傳的時候，會使用 move operation 來把內部配置的記憶體空間的所有權轉換到外部來。
 
** shared_ptr
和 unique_ptr 的獨佔性質不同，shared_ptr 的設計目的，就是要讓多個 shared_ptr 可
以共用一份記憶體空間，並且在沒有要繼續使用的時候，可以自動把所用的資源釋放掉。而
由於它的資源是可以共用的，所以也就可以透過 operator= 等方法，來分享 shared_ptr
所使用的資源。

下面是一個例子：

#+BEGIN_SRC c++
  {
    shared_ptr<int> a;  // a is empty
    {
      shared_ptr<int> b( new int( 10 ) );  // allocate resource
      a = b;  // reference counter: 2
      {
        shared_ptr<int> c = a;  // reference counter: 3
        ,*c = 100;
      }  // c dead, reference counter: 2
    } // b dead, reference counter: 1
    cout << *a << endl;
  }  // release resource

#+END_SRC

在這個例子裡，a 被宣告出來的時候，實際上是一個空的指標，並沒有去配置實際的記憶體
空間。等到建立 b 的時候，才去配置了一塊 int 大小的記憶體空間，並在裡面寫入 10 這
個數值。

而 a = b; 這個指令，則是讓 a 去共用 b 所配置出來的記憶體空間；這時候由於 a 和 b
都是使用同一塊記憶體空間，所以這塊記憶體空間的 reference counter 就是 2、代表他
被兩個 shared_ptr 共用。

接下來，則是再建立另一個 shared_ptr c，也來共用這塊記憶體空間，這時候 reference
counter 也就變成 3 了。而由於 a、b、c 都是使用同一塊記憶體空間，所以接下來透過
*c = 100; 來做值的修改的時候，其實去修改的就是共用的記憶體空間，所以這時候 *a 或
*b 的值也都會和 c 一樣變成 100。

再來，當 c 和 b 的生命週期依序結束的時候，reference counter 的值也會降成 2、1，
代表有使用到這塊記憶體空間的 shared_ptr 越來越少。在最後透過 iostream 輸出 *a 的
時候，也就只剩下 a 還有在使用這塊記憶體空間了；但是，也由於 a 還在繼續使用這塊記
憶體空間，所以記憶體空間雖然是在建立 b 的時候所配置的、但是並不會隨著 b 的消失而
被釋放掉，而是要等到 a 也因為生命週期到了、讓 reference counter 降到 0，資源才會
真正被釋放掉。

而他主要的用途，其中一個應該還是算用在不同 class 間做資料的共用、交換。例如下面
是一個例子：

#+BEGIN_SRC c++
  class DataGenerator
  {
  public:
    DataGenerator()
    {
      a = shared_ptr<int>( new int(0) );
    }

    shared_ptr<int> GetData()
    {
      return a;
    }

  private:
    shared_ptr<int> a;
  };
#+END_SRC
在 DataGenerator 這個類別裡，有一個要和外部做資料共用的變數 a、型別是 shared_ptr<int>。

#+BEGIN_SRC c++
DataGenerator DataGen;
shared_ptr<int> A = DataGen.GetData();
#+END_SRC

而當外部透過 GetData() 取得這個資料的時候，由於也是 shared_ptr 的形式，所以會做
自動資源管理、不需要像傳統的 pointer 一樣刻意透過 delete 去釋放他的資源，也不用
再去擔心要在哪裡 delete、或是因為沒有 delete 而產生 memory leak 了～

最後，微軟是建議在建立第一個 shared_ptr 的時候，使用 make_shared() 這個 template
函式來建立，在效率上會比較好；下面是一個使用的例子：

shared_ptr<int> b = make_shared<int>( 10 );
 
** weak_ptr
C++ 11 的最後一個 smart pointer，是 weak_ptr，他基本上是一個需要搭配 shared_ptr
來一起使用的特例；和 shared_ptr 不同的地方在於，除了他不會增加內部的 reference
counter 的計數（註 1）外，它基本上也不能用來做資料的存取，主要只能用來監控
shared_ptr 目前的狀況。

下面是一個簡單的例子：

#+BEGIN_SRC c++
weak_ptr<int> w1;
{
  shared_ptr<int> a( new int(10) );
  w1 = a;
}
#+END_SRC

首先，先宣告一個空的 weak_ptr 的物件 w1，接著在一個比較小的 scope 裡面，建立一個
shared_ptr a、並配置所需要的記憶體空間；然後，直接以 w1 = a; 這樣的程式碼，讓 w1
去使用 a 的資源。

但是接下來當 a 消失之後，雖然 w1 還在使用 a 所配置的資源，但是由於 w1 只是
weak_ptr，所以並不會要求系統把資源留下來使用，而是會隨著 a 的消失、把相關的資源
釋放掉。

而由於 weak_ptr 本身不能用來做資料的存取，所以如果要使用的話，實際上是需要先將
weak_ptr 轉換回 shared_ptr 的。轉換的方法也很簡單，就是使用 weak_ptr 提供的
lock() 這個函式，來產生一個有擁有權的 shared_ptr。使用範例基本上如下：

#+BEGIN_SRC c++
shared_ptr<int> b = w1.lock();
#+END_SRC

而由於 weak_ptr 所使用的資源不一定存在（其實 unique_ptr 和 shared_ptr 也一樣），
所以在轉換後，基本上是建議要加上檢查的程式、確認他的狀態：

#+BEGIN_SRC c++
shared_ptr<int> b = w1.lock();
if( b != nullptr )
  cout << *b << endl;
#+END_SRC
 
C++ 11 的 Smart Pointer 大概就先介紹到這邊了。不過最後再補充一下，基本上，unique_ptr 是有支援陣列的使用的～例如：

#+BEGIN_SRC c++
unique_ptr<int[]> a( new int[10] );
for( unsigned int i = 0; i < 10; ++ i )
  a[i] = i;
#+END_SRC

但是相對的，shared_ptr 並不支援這樣的使用方法；如果要使用 shared_ptr 來管理陣列，基本上作法大概會是：

#+BEGIN_SRC c++
shared_ptr<int> a( new int[10], []( int* ptr ){ delete [] ptr; } );
int* p = a.get();
for( int i = 0; i < 10; ++ i )
  p[i] = i;
#+END_SRC

要注意的是，由於 shared_ptr 預設是會用 delete ptr; 來做資源釋放的動作，如果是陣
列的話，需要自己額外給一個 function object 來取代預設的 delete，做為特定的資源釋
放函式，而 Heresy 這邊是用 Lambda expression 來寫（上面黃底的部分）。

另外，shared_ptr 也沒有像 unique_ptr 一樣可以直接用 operator[] 來做陣列資料的讀
取，所以必須要先透過 get() 來取的傳統型式的指標，然後再來進行操作，算是比較麻煩
的。

附註
在 Microsoft Visual C++ 10 的 STL 實作裡，shared_ptr 和 weak_ptr 應該是有各自的
計數器，在偵錯時如果去監看的話，可以看到「strong ref」和「weak ref」的數值。

unique_ptr 和 shared_ptr 都可以透過和 NULL 或 nullptr 做比較，來確認指標是否有效。

如果要強制釋放 smart pointer 的資源的話，可以呼叫他的 reset() 函式。


* C++0x：Lambda expression

Lambda expression 是之前《C++ 語法再加強：C++0x》一文中列出的 MSVC++10 在 C++
core language 加入的第三項新功能。他的基本概念是一個「匿名函式 (anonymous
function)」，可以用來快速地建立一個沒有名稱的 function object 來使用。也因此，除
了宣告的方法以及使用目的不太一樣外，實際上他很類似一般的 function。

而 lambda expression 的語法定義（參考 MSDN），則如下：

#+BEGIN_SRC c++
[]() mutable throw() -> typeid
{
  //function body
}
#+END_SRC
要細分的話，可以把它拆成六個部份，個別的意義分別是：

[] : lambda introducer, capture clause

lambda expression 基本上就是由 [] 開始的，而且也是 lambda expression 的語法中絕
對不能省略的部分；它的目的是用來告訴編譯器接下來的就是要開始寫 lambda expression
了～

不過實際上除了 introducer 的功能外，他還包含了所謂「capture」的功能，可以把
lambda expression 所在的 scope 內可以讀到的變數抓到 lambda expression 裡使用；而
使用上也可以設定為 by value 或 by reference。除了一個一個變數設定外，可以直接使
用 = 和 & 設定預設 capture（capture-default）；前者是預設將所有變數以 by value
的方式抓進來、後者則是將所有變數以 by reference 的方式抓進來。

下面是用比較單純的例子來說明：

1: []      // 不使用外部的變數
2: [=]     // 全部 capture by value
3: [&]     // 全部 capture by reference
4: [x, &y] // x by value, y by reference
5: [=, &y] // 除了 y by reference 外，其他全部 by value
6: [&, x]  // 除了 x by value 外，其他全部 by reference

其中要注意的是，capture-default（=、&）要放在 capture list 的第一項。
此外，上面的例子裡的 4/5/6，如果在外部變數只有 x 和 y 的情況下，這三種寫法會是等價的。
() : parameter declaration list

要傳入這個匿名函釋的變數，基本上就像一般的 function 一樣的用法，不過多加了一些限制：
不能有預設值
不能有可變長度的參數列表
不能有沒命名的參數
另外，在不需要傳參數進 lambda expression 的時候，是可以直接把 () 省略的。
mutable : mutable specification
可以省略的東西。加上了 mutable 後，是讓 lambda expression 可以修改 capture by value 的外部變數。
（Heresy 不太瞭的是，要修改的用 by reference 的方法抓近來不就好了？）
throw() : exception specification
可以省略的東西。這其實是一般函式就可以加的功能，可以用來指定這個函式會不會丟出例外狀況（exception）、丟出哪種類型的例外狀況；詳細可以參考《C++ Exception Handling》和《Exception Specifications》。
-> typeid : return type clause
指定 lambda 回傳值的型別。在 lambda body 沒有回傳（return）或是只有一種回傳路徑的情況下，編譯器會自動判斷回傳的型別，所以可以把這部分也省略掉。
{…} : function body
這個 lambda expression 要做的事，就像一般 function 的程式內容。
而 lambda expression 的好處，就是可以不用實際宣告出函式，而直接拿來當 funciton object 使用。實際使用的時候，最普遍的用法應該是用在像是 STL <algorithm> 裡的函式，把 function 當參數傳進去了～
例如下面的程式就是在 C++98 時，要使用 for_each() 時的寫法：
class LambdaFunctor
{
public:
  void operator()(int n) const
  {
    cout << n << " ";
  }
};
  
int main()
{
  vector<int> v;
  for( int i = 0; i < 10; ++i )
    v.push_back(i);
  
  for_each( v.begin(), v.end(), LambdaFunctor() );
  cout << endl;
}
而如果改用 lambda expression 的話，就可以變成：
int main() {
  vector<int> v;
  for (int i = 0; i < 10; ++i)
    v.push_back(i);
  
  for_each(v.begin(), v.end(), [](int n) { cout << n << " "; } );
  cout << endl;
}
這樣應該很明顯看得出來，使用 lambda expression 的好處，就是可以不必額外寫出 LambdaFunctor 這個 function class 了～
而如果要使用 capture-list 的話，下方是一個簡單的例子，他會把 vector v 中，值介於 4 到 7 之間的項目給刪除掉：
int main()
{
  vector<int> v;
  for( int i = 0; i < 10; ++i )
    v.push_back(i);
  
  int x = 4;
  int y = 7;
  
  v.erase( remove_if( v.begin(), v.end(), 
                      [x, y](int n) { return x < n && n < y; } ),
           v.end());
 
  for_each(v.begin(), v.end(), [](int n) { cout << n << " "; });
  cout << endl;
}
如果在 lambda introducer 裡的 capture list 裡沒有加上 x、y 的話，是會因為在 lambda function 裡找不到變數 x、y 而編譯錯誤的。
如果是要用 by reference 的話，下面是一個把 vector 加總的簡單範例：
vector<int> v;
//...
  
int sum = 0;
for_each( v.begin(), v.end(), [&sum]( int n ){ sum += n; } );
最後，由於 lambda expression 會產生類似 function obejct 的物件，所以其實我們可以用 auto（參考）或是 tr1 的 function（參考）來把 lambda expression 儲存下來；不過可能要注意的是，如果是用 auto 來儲存 lambda expression 的話，每次都會是不同的型別的！下面就是一個簡單的範例：
#include <functional>
#include <iostream>
  
using namespace std;
  
int main()
{
  function<void (int)> g1 = [](int n){cout << n;};
  function<void (int)> g2 = [](int n){cout << n;};
  auto g3 = [](int n){cout << n;};
  auto g4 = [](int n){cout << n;};
  
  cout << typeid( g1 ).name() << endl;
  cout << typeid( g2 ).name() << endl;
  cout << typeid( g3 ).name() << endl;
  cout << typeid( g4 ).name() << endl;
}
這樣的一段程式用 VC10 編譯後執行的結果會是：
class std::tr1::function
class std::tr1::function
class `anonymous namespace'::
class `anonymous namespace'::
其中可以發現，如果用 auto 來儲存 lambda expression 的話，兩個同樣寫法的 lambda expression 會被當成兩種不同型別的物件，所以兩者也是不能互換的～
另外一提，由於 lambda expression 本身可以直接當作 function object 來使用，所以下面的語法是合法的，就相當於直接呼叫這個沒有名稱的 function object：
int a = [](){return 5;}();
甚至，下面這兩行看起來很詭異的程式，也是合法的語法～
[](){}();
[]{}();
參考資料：



* Type conversions
Implicit conversion
Implicit conversions are automatically performed when a value is copied to a compatible type. For example:

short a=2000;
int b;
b=a;


Here, the value of a is promoted from short to int without the need of any explicit operator. This is known as a standard conversion. Standard conversions affect fundamental data types, and allow the conversions between numerical types (short to int, int to float, double to int...), to or from bool, and some pointer conversions.

Converting to int from some smaller integer type, or to double from float is known as promotion, and is guaranteed to produce the exact same value in the destination type. Other conversions between arithmetic types may not always be able to represent the same value exactly:
If a negative integer value is converted to an unsigned type, the resulting value corresponds to its 2's complement bitwise representation (i.e., -1 becomes the largest value representable by the type, -2 the second largest, ...).
The conversions from/to bool consider false equivalent to zero (for numeric types) and to null pointer (for pointer types); true is equivalent to all other values and is converted to the equivalent of 1.
If the conversion is from a floating-point type to an integer type, the value is truncated (the decimal part is removed). If the result lies outside the range of representable values by the type, the conversion causes undefined behavior.
Otherwise, if the conversion is between numeric types of the same kind (integer-to-integer or floating-to-floating), the conversion is valid, but the value is implementation-specific (and may not be portable).

Some of these conversions may imply a loss of precision, which the compiler can signal with a warning. This warning can be avoided with an explicit conversion.

For non-fundamental types, arrays and functions implicitly convert to pointers, and pointers in general allow the following conversions:
Null pointers can be converted to pointers of any type
Pointers to any type can be converted to void pointers.
Pointer upcast: pointers to a derived class can be converted to a pointer of an accessible and unambiguous base class, without modifying its const or volatile qualification.

Implicit conversions with classes
In the world of classes, implicit conversions can be controlled by means of three member functions:
Single-argument constructors: allow implicit conversion from a particular type to initialize an object.
Assignment operator: allow implicit conversion from a particular type on assignments.
Type-cast operator: allow implicit conversion to a particular type.

For example:

// implicit conversion of classes:
#include <iostream>
using namespace std;

class A {};

class B {
public:
  // conversion from A (constructor):
  B (const A& x) {}
  // conversion from A (assignment):
  B& operator= (const A& x) {return *this;}
  // conversion to A (type-cast operator)
  operator A() {return A();}
};

int main ()
{
  A foo;
  B bar = foo;    // calls constructor
  bar = foo;      // calls assignment
  foo = bar;      // calls type-cast operator
  return 0;
}
 
Edit & Run


The type-cast operator uses a particular syntax: it uses the operator keyword followed by the destination type and an empty set of parentheses. Notice that the return type is the destination type and thus is not specified before the operator keyword.

Keyword explicit
On a function call, C++ allows one implicit conversion to happen for each argument. This may be somewhat problematic for classes, because it is not always what is intended. For example, if we add the following function to the last example:

 
void fn (B arg) {}


This function takes an argument of type B, but it could as well be called with an object of type A as argument:

 
fn (foo);


This may or may not be what was intended. But, in any case, it can be prevented by marking the affected constructor with the explicit keyword:

// explicit:
#include <iostream>
using namespace std;

class A {};

class B {
public:
  explicit B (const A& x) {}
  B& operator= (const A& x) {return *this;}
  operator A() {return A();}
};

void fn (B x) {}

int main ()
{
  A foo;
  B bar (foo);
  bar = foo;
  foo = bar;
  
//  fn (foo);  // not allowed for explicit ctor.
  fn (bar);  

  return 0;
}
Edit & Run


Additionally, constructors marked with explicit cannot be called with the assignment-like syntax; In the above example, bar could not have been constructed with:

 
B bar = foo;


Type-cast member functions (those described in the previous section) can also be specified as explicit. This prevents implicit conversions in the same way as explicit-specified constructors do for the destination type.

Type casting
C++ is a strong-typed language. Many conversions, specially those that imply a different interpretation of the value, require an explicit conversion, known in C++ as type-casting. There exist two main syntaxes for generic type-casting: functional and c-like:

1
2
3
4
double x = 10.3;
int y;
y = int (x);    // functional notation
y = (int) x;    // c-like cast notation 


The functionality of these generic forms of type-casting is enough for most needs with fundamental data types. However, these operators can be applied indiscriminately on classes and pointers to classes, which can lead to code that -while being syntactically correct- can cause runtime errors. For example, the following code compiles without errors: 

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
// class type-casting
#include <iostream>
using namespace std;

class Dummy {
    double i,j;
};

class Addition {
    int x,y;
  public:
    Addition (int a, int b) { x=a; y=b; }
    int result() { return x+y;}
};

int main () {
  Dummy d;
  Addition * padd;
  padd = (Addition*) &d;
  cout << padd->result();
  return 0;
}
 
Edit & Run


The program declares a pointer to Addition, but then it assigns to it a reference to an object of another unrelated type using explicit type-casting:

 
padd = (Addition*) &d;


Unrestricted explicit type-casting allows to convert any pointer into any other pointer type, independently of the types they point to. The subsequent call to member result will produce either a run-time error or some other unexpected results.

In order to control these types of conversions between classes, we have four specific casting operators: dynamic_cast, reinterpret_cast, static_cast and const_cast. Their format is to follow the new type enclosed between angle-brackets (<>) and immediately after, the expression to be converted between parentheses.

dynamic_cast <new_type> (expression)
reinterpret_cast <new_type> (expression)
static_cast <new_type> (expression)
const_cast <new_type> (expression)

The traditional type-casting equivalents to these expressions would be:

(new_type) expression
new_type (expression)

but each one with its own special characteristics:

dynamic_cast
dynamic_cast can only be used with pointers and references to classes (or with void*). Its purpose is to ensure that the result of the type conversion points to a valid complete object of the destination pointer type.

This naturally includes pointer upcast (converting from pointer-to-derived to pointer-to-base), in the same way as allowed as an implicit conversion.

But dynamic_cast can also downcast (convert from pointer-to-base to pointer-to-derived) polymorphic classes (those with virtual members) if -and only if- the pointed object is a valid complete object of the target type. For example:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
// dynamic_cast
#include <iostream>
#include <exception>
using namespace std;

class Base { virtual void dummy() {} };
class Derived: public Base { int a; };

int main () {
  try {
    Base * pba = new Derived;
    Base * pbb = new Base;
    Derived * pd;

    pd = dynamic_cast<Derived*>(pba);
    if (pd==0) cout << "Null pointer on first type-cast.\n";

    pd = dynamic_cast<Derived*>(pbb);
    if (pd==0) cout << "Null pointer on second type-cast.\n";

  } catch (exception& e) {cout << "Exception: " << e.what();}
  return 0;
}
Null pointer on second type-cast.
Edit & Run


Compatibility note: This type of dynamic_cast requires Run-Time Type Information (RTTI) to keep track of dynamic types. Some compilers support this feature as an option which is disabled by default. This needs to be enabled for runtime type checking using dynamic_cast to work properly with these types.

The code above tries to perform two dynamic casts from pointer objects of type Base* (pba and pbb) to a pointer object of type Derived*, but only the first one is successful. Notice their respective initializations:

1
2
Base * pba = new Derived;
Base * pbb = new Base;


Even though both are pointers of type Base*, pba actually points to an object of type Derived, while pbb points to an object of type Base. Therefore, when their respective type-casts are performed using dynamic_cast, pba is pointing to a full object of class Derived, whereas pbb is pointing to an object of class Base, which is an incomplete object of class Derived.

When dynamic_cast cannot cast a pointer because it is not a complete object of the required class -as in the second conversion in the previous example- it returns a null pointer to indicate the failure. If dynamic_cast is used to convert to a reference type and the conversion is not possible, an exception of type bad_cast is thrown instead.

dynamic_cast can also perform the other implicit casts allowed on pointers: casting null pointers between pointers types (even between unrelated classes), and casting any pointer of any type to a void* pointer.

static_cast
static_cast can perform conversions between pointers to related classes, not only upcasts (from pointer-to-derived to pointer-to-base), but also downcasts (from pointer-to-base to pointer-to-derived). No checks are performed during runtime to guarantee that the object being converted is in fact a full object of the destination type. Therefore, it is up to the programmer to ensure that the conversion is safe. On the other side, it does not incur the overhead of the type-safety checks of dynamic_cast.

1
2
3
4
class Base {};
class Derived: public Base {};
Base * a = new Base;
Derived * b = static_cast<Derived*>(a);


This would be valid code, although b would point to an incomplete object of the class and could lead to runtime errors if dereferenced.

Therefore, static_cast is able to perform with pointers to classes not only the conversions allowed implicitly, but also their opposite conversions.

static_cast is also able to perform all conversions allowed implicitly (not only those with pointers to classes), and is also able to perform the opposite of these. It can:
Convert from void* to any pointer type. In this case, it guarantees that if the void* value was obtained by converting from that same pointer type, the resulting pointer value is the same.
Convert integers, floating-point values and enum types to enum types.

Additionally, static_cast can also perform the following:
Explicitly call a single-argument constructor or a conversion operator.
Convert to rvalue references.
Convert enum class values into integers or floating-point values.
Convert any type to void, evaluating and discarding the value.

reinterpret_cast
reinterpret_cast converts any pointer type to any other pointer type, even of unrelated classes. The operation result is a simple binary copy of the value from one pointer to the other. All pointer conversions are allowed: neither the content pointed nor the pointer type itself is checked.

It can also cast pointers to or from integer types. The format in which this integer value represents a pointer is platform-specific. The only guarantee is that a pointer cast to an integer type large enough to fully contain it (such as intptr_t), is guaranteed to be able to be cast back to a valid pointer.

The conversions that can be performed by reinterpret_cast but not by static_cast are low-level operations based on reinterpreting the binary representations of the types, which on most cases results in code which is system-specific, and thus non-portable. For example:

1
2
3
4
class A { /* ... */ };
class B { /* ... */ };
A * a = new A;
B * b = reinterpret_cast<B*>(a);


This code compiles, although it does not make much sense, since now b points to an object of a totally unrelated and likely incompatible class. Dereferencing b is unsafe.

const_cast
This type of casting manipulates the constness of the object pointed by a pointer, either to be set or to be removed. For example, in order to pass a const pointer to a function that expects a non-const argument:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
// const_cast
#include <iostream>
using namespace std;

void print (char * str)
{
  cout << str << '\n';
}

int main () {
  const char * c = "sample text";
  print ( const_cast<char *> (c) );
  return 0;
}
sample text
Edit & Run


The example above is guaranteed to work because function print does not write to the pointed object. Note though, that removing the constness of a pointed object to actually write to it causes undefined behavior.

typeid
typeid allows to check the type of an expression: 

typeid (expression)

This operator returns a reference to a constant object of type type_info that is defined in the standard header <typeinfo>. A value returned by typeid can be compared with another value returned by typeid using operators == and != or can serve to obtain a null-terminated character sequence representing the data type or class name by using its name() member.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
// typeid
#include <iostream>
#include <typeinfo>
using namespace std;

int main () {
  int * a,b;
  a=0; b=0;
  if (typeid(a) != typeid(b))
  {
    cout << "a and b are of different types:\n";
    cout << "a is: " << typeid(a).name() << '\n';
    cout << "b is: " << typeid(b).name() << '\n';
  }
  return 0;
}
a and b are of different types:
a is: int *
b is: int  
Edit & Run


When typeid is applied to classes, typeid uses the RTTI to keep track of the type of dynamic objects. When typeid is applied to an expression whose type is a polymorphic class, the result is the type of the most derived complete object:

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
// typeid, polymorphic class
#include <iostream>
#include <typeinfo>
#include <exception>
using namespace std;

class Base { virtual void f(){} };
class Derived : public Base {};

int main () {
  try {
    Base* a = new Base;
    Base* b = new Derived;
    cout << "a is: " << typeid(a).name() << '\n';
    cout << "b is: " << typeid(b).name() << '\n';
    cout << "*a is: " << typeid(*a).name() << '\n';
    cout << "*b is: " << typeid(*b).name() << '\n';
  } catch (exception& e) { cout << "Exception: " << e.what() << '\n'; }
  return 0;
}
a is: class Base *
b is: class Base *
*a is: class Base
*b is: class Derived
Edit & Run


Note: The string returned by member name of type_info depends on the specific implementation of your compiler and library. It is not necessarily a simple string with its typical type name, like in the compiler used to produce this output. 

Notice how the type that typeid considers for pointers is the pointer type itself (both a and b are of type class Base *). However, when typeid is applied to objects (like *a and *b) typeid yields their dynamic type (i.e. the type of their most derived complete object).

If the type typeid evaluates is a pointer preceded by the dereference operator (*), and this pointer has a null value, typeid throws a bad_typeid exception.
* https://kheresy.wordpress.com/2011/10/12/c11_standard/

* XML read/write -> pugixml

using namespace pugi;
using namespace Common;

https://github.com/zeux/pugixml

* enum class :
#+BEGIN_SRC c++
enum class Error {
  Success,
  NullPointer,
  NotImplemented,
  InvalidArgument,
  ValueNotRetrieved,
  ConfigFormatError,
  ConfigEntryNotFound,
  ConfigParsedError,
  ConfigValueIncorrect,
};

  Error Load(const char* filename, ConfigFile* config);
  Error CheckXmlElements(const pugi::xml_document& doc);
  Error CheckXmlSingleElement(const pugi::xml_node& node, const std::string& childnodename);
  Error ParseVersion(const pugi::xml_node& tslite_node, ConfigFile* config);
  Error ParseConnection(const pugi::xml_node& connection_node, ConfigFile* config);

#+END_SRC

* enum :
#+BEGIN_SRC c++
enum FlashCommandEnum
{
  Idle = 0x0,
  WriteBlock = 0x2,
  EraseAll = 0x3,
  WriteLockdownBlock = 0x4,
  ReadConfigurationBlock = 0x5,
  WriteConfigurationBlock = 0x6,
  EraseConfiguration = 0x7,
  EnableFlashProgramming = 0xF
};

#+END_SRC

* unique_ptr ;
#+BEGIN_SRC c++
  std::unique_ptr<Data::TestLimitReader> m_reader;
  m_reader = std::unique_ptr<TestLimitReader>(new TestLimitReader(txNum, rxNum));
#+END_SRC

* check file exist or not :

#+BEGIN_SRC c++
  inline bool FileExist(const string& name) {
    std::ifstream file(name.c_str());
    bool exist = file.good();
    file.close();
    return exist;
  }
#+END_SRC

* Basic Excel 

#+BEGIN_SRC c++
  ExcelFormat::BasicExcel* xls = new ExcelFormat::BasicExcel();
  if (!xls->Load(sensorLimitFile.c_str())) {
    error_message_ = "'" + sensorLimitFile + "' is not loaded successfully";
    return false;
   }
  int total = xls->GetTotalWorkSheets();
  char temp[1024];
  for (int i = 0; i < total; ++i) {
    if (!xls->GetSheetName(i, &temp[0])) continue;

    string name = temp;

#+END_SRC

* NULL vs nullptr

#+BEGIN_SRC c++
nullptr is always a pointer type. 0 (aka. C's NULL bridged over into C++) could
cause ambiguity in overloaded function resolution, among other things:

f(int);
f(foo *);
#+END_SRC

* Thread delete :

#+BEGIN_SRC c++
  std::thread deletethread([](ExcelFormat::BasicExcel* pXls){ delete pXls; }, xls);
  deletethread.detach();
#+END_SRC

* Copy Constructor in C++

We have discussed introduction to Constructors in C++. In this post, copy
constructor is discussed.

What is a copy constructor?

A copy constructor is a member function which initializes an object using
another object of the same class. A copy constructor has the following general
function prototype:


#+BEGIN_SRC c++
	ClassName (const ClassName &old_obj); 
#+END_SRC


Following is a simple example of copy constructor.
** EX :

#+BEGIN_SRC c++
  #include<iostream>
  using namespace std;

  class Point
  {
  private:
      int x, y;
  public:
      Point(int x1, int y1) { x = x1; y = y1; }

      // Copy constructor
      Point(const Point &p2) {x = p2.x; y = p2.y; }

      int getX()            {  return x; }
      int getY()            {  return y; }
  };

  int main()
  {
      Point p1(10, 15); // Normal constructor is called here
      Point p2 = p1; // Copy constructor is called here

      // Let us access values assigned by constructors
      cout << "p1.x = " << p1.getX() << ", p1.y = " << p1.getY();
      cout << "\np2.x = " << p2.getX() << ", p2.y = " << p2.getY();

      return 0;
  }

#+END_SRC


Output: 


p1.x = 10, p1.y = 15
p2.x = 10, p2.y = 15 


** When is copy constructor called?
In C++, a Copy Constructor may be called in following cases:
1. When an object of the class is returned by value.
2. When an object of the class is passed (to a function) by value as an argument.
3. When an object is constructed based on another object of the same class.
4. When compiler generates a temporary object.

It is however, not guaranteed that a copy constructor will be called in all
these cases, because the C++ Standard allows the compiler to optimize the copy
away in certain cases, one example being the return value optimization
(sometimes referred to as RVO).

Source: http://www.geeksforgeeks.org/g-fact-13/

** When is user defined copy constructor needed?
If we don’t define our own copy constructor, the C++ compiler creates a default
copy constructor for each class which does a member wise copy between objects.
The compiler created copy constructor works fine in general. We need to define
our own copy constructor only if an object has pointers or any run time
allocation of

resource like file handle, a network connection..etc.

** Copy constructor vs Assignment Operator
Which of the following two statements call copy constructor and which one calls assignment operator?


MyClass t1, t2;
MyClass t3 = t1;  // ----> (1)
t2 = t1;          // -----> (2) 


_Copy constructor is called when a new object is created from an existing object_
_as a copy of the existing object. Assignment operator is called when an already_
_initialized object is assigned a new value from another existing object. In the_
_above example (1) calls copy constrictor and (2) calls assignment operator. See_
_this for_

** more details.

Write an example class where copy constructor is needed?
Following is a complete C++ program to demonstrate use of Copy constructor. In
the following String class, we must write copy constructor.


#+BEGIN_SRC c++
  #include<iostream>
  #include<cstring>
  using namespace std;

  class String
  {
  private:
    char *s;
    int size;
  public:
    String(const char *str = NULL); // constructor
    ~String() { delete [] s;  }// destructor
    String(const String&); // copy constructor
    void print() { cout << s << endl; } // Function to print string
    void change(const char *);  // Function to change
  };

  String::String(const char *str)
  {
    size = strlen(str);
    s = new char[size+1];
    strcpy(s, str);
  }

  void String::change(const char *str)
  {
    delete [] s;
    size = strlen(str);
    s = new char[size+1];
    strcpy(s, str);
  }

  String::String(const String& old_str)
  {
    size = old_str.size;
    s = new char[size+1];
    strcpy(s, old_str.s);
  }

  int main()
  {
    String str1("GeeksQuiz");
    String str2 = str1;

    str1.print(); // what is printed ?
    str2.print();

    str2.change("GeeksforGeeks");

    str1.print(); // what is printed now ?
    str2.print();
    return 0;
  }


  /*
  Output: 

  GeeksQuiz
  GeeksQuiz
  GeeksQuiz
  GeeksforGeeks
  ,*/
#+END_SRC




** What would be the problem if we remove copy constructor from above code?
If we remove copy constructor from above program, we don’t get the expected
output. The changes made to str2 reflect in str1 as well which is never
expected.


#+BEGIN_SRC c++
  #include<iostream>
  #include<cstring>
  using namespace std;

  class String
  {
  private:
    char *s;
    int size;
  public:
    String(const char *str = NULL); // constructor
    ~String() { delete [] s;  }// destructor
    void print() { cout << s << endl; }
    void change(const char *);  // Function to change
  };

  String::String(const char *str)
  {
    size = strlen(str);
    s = new char[size+1];
    strcpy(s, str);
  }

  void String::change(const char *str)
  {
    delete [] s;
    size = strlen(str);
    s = new char[size+1];
    strcpy(s, str);
  }

  int main()
  {
    String str1("GeeksQuiz");
    String str2 = str1;

    str1.print(); // what is printed ?
    str2.print();

    str2.change("GeeksforGeeks");

    str1.print(); // what is printed now ?
    str2.print();
    return 0;
  }


  /*
    Output:

    GeeksQuiz
    GeeksQuiz
    GeeksforGeeks
    GeeksforGeeks


  ,*/
#+END_SRC


** Can we make copy constructor private?
Yes, a copy constructor can be made private. When we make a copy constructor
private in a class, objects of that class become non-copyable. This is
particularly useful when our class has pointers or dynamically allocated
resources. In such situations, we can either write our own copy constructor like
above String example,

or make a private copy constructor so that users get compiler errors rather than
surprises at run time.

Why argument to a copy constructor must be passed as a reference?

A copy constructor is called when an object is passed by value. Copy constructor
itself is a function. So if we pass argument by value in a copy constructor, a
call to copy constructor would be made to call copy constructor which becomes a
non-terminating chain of calls. Therefore compiler doesn’t allow parameters to
be pass by value.

Why argument to a copy constructor should be const?
See http://www.geeksforgeeks.org/copy-constructor-argument-const/

* Operator Overloading in C++

In C++, we can make operators to work for user defined classes. For example, we can overload an operator ‘+’ in a class like String so
that we can concatenate two strings by just using +.
Other example classes where arithmetic operators may be overloaded are Complex Number, Fractional Number, Big Integer, etc.

** A simple and complete example 

#+BEGIN_SRC c++
  #include<iostream>
  using namespace std;

  class Complex {
  private:
    int real, imag;
  public:
    Complex(int r = 0, int i =0)  {real = r;   imag = i;}

    // This is automatically called when '+' is used with
    // between two Complex objects
    Complex operator + (Complex const &obj) {
      Complex res;
      res.real = real + obj.real;
      res.imag = imag + obj.imag;
      return res;
    }
    void print() { cout << real << " + i" << imag << endl; }
  };

  int main()
  {
    Complex c1(10, 5), c2(2, 4);
    Complex c3 = c1 + c2; // An example call to "operator+"
    c3.print();
  }

  /*
  Output:

  12 + i9
  ,*/
#+END_SRC



** What is the difference between operator functions and normal functions?
Operator functions are same as normal functions. The only differences are, name
of an operator function is always operator keyword

followed by symbol of operator and operator functions are called when the
corresponding operator is used.

*** Following is an example of global operator function.


#+BEGIN_SRC c++
  #include<iostream>
  using namespace std;

  class Complex {
  private:
    int real, imag;
  public:
    Complex(int r = 0, int i =0)  {real = r;   imag = i;}
    void print() { cout << real << " + i" << imag << endl; }

    // The global operator function is made friend of this class so
    // that it can access private members
    friend Complex operator + (Complex const &, Complex const &);
  };


  Complex operator + (Complex const &c1, Complex const &c2)
  {
    return Complex(c1.real + c2.real, c1.imag + c2.imag);
  }


  int main()
  {
    Complex c1(10, 5), c2(2, 4);
    Complex c3 = c1 + c2; // An example call to "operator+"
    c3.print();
    return 0;
  }

#+END_SRC


** Can we overload all operators?

Almost all operators can be overloaded except few. Following is the list of
operators that cannot be overloaded.


   . (dot) 
   :: 
   ?: 
   sizeof 


Why can’t . (dot), ::, ?: and sizeof be overloaded?
See this for answers from Stroustrup himself. 

Important points about operator overloading
1) For operator overloading to work, at leas one of the operands must be a user defined class object.

2) Assignment Operator: Compiler automatically creates a default assignment operator with every class. The default assignment
operator does assign all members of right side to the left side and works fine most of the cases (this behavior is same as copy
constructor). See this for more details. 

3) Conversion Operator: We can also write conversion operators that can be used to convert one type to another type.

#+BEGIN_SRC c++
  #include <iostream>
  using namespace std;
  class Fraction
  {
      int num, den;
  public:
      Fraction(int n,  int d) { num = n; den = d; }

      // conversion operator: return float value of fraction
      operator float() const {
          return float(num) / float(den);
      }
  };

  int main() {
      Fraction f(2, 5);
      float val = f;
      cout << val;
      return 0;
  }


  /*
  Output:

  0.4

  ,*/
#+END_SRC
Overloaded conversion operators must be a member method. Other operators can either be member method or global method.

4) Any constructor that can be called with a single argument works as a conversion constructor, means it can also be used for implicit
conversion to the class being constructed.


#+BEGIN_SRC c++
  #include<iostream>
  using namespace std;

  class Point
  {
  private:
    int x, y;
  public:
    Point(int i = 0, int j = 0) {
      x = i;   y = j;
    }
    void print() {
      cout << endl << " x = " << x << ", y = " << y;
    }
  };

  int main() {
    Point t(20, 20);
    t.print();
    t = 30;   // Member x of t becomes 30
    t.print();
    return 0;
  }
#+END_SRC


Output:


 x = 20, y = 20
 x = 30, y = 0


We will soon be discussing overloading of some important operators like new, delete, comma, function call, arrow, etc.

* check :
#+BEGIN_SRC c++
  // check
  int main(int nArgs, char ** vArgs)
  {
    vector<int> *v = new vector<int>(10);
    v->at(2); //Retrieve using pointer to member
    v->operator[](2); //Retrieve using pointer to operator member
    v->size(); //Retrieve size
    vector<int> &vr = *v; //Create a reference
    vr[2]; //Normal access through reference
    delete &vr; //Delete the reference. You could do the same with
    //a pointer (but not both!)
  }
  // check
  std::vector<int>* v = new std::vector<int>();

  v->push_back(0);
  v->push_back(12);
  v->push_back(1);

  int twelve = v->at(1);
  int one = (*v)[2];

  // iterate it
  for(std::vector<int>::const_iterator cit = v->begin(), e = v->end; 
      cit != e;  ++cit)
    {
      int value = *cit;
    }

  // or, more perversely
  for(int x = 0; x < v->size(); ++x)
    {
      int value = (*v)[x];
    }
#+END_SRC
