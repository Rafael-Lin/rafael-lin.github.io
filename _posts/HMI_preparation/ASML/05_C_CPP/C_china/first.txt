最近因為找工作，收集了很多C語言方面方面的面試題以及答案。現在新工作搞定了，決定把這些資料發出來，送給有需要的朋友，免得再象我一樣到處搜尋，實在辛苦。

發布之前先申明兩點：
    1 所有資料來自網絡(主要是CSDN)，本人只是收集和轉發。
    2 所有問題解答(尤其是代碼)只是參考，不保證正確。

先發基本問題，再發編程問題..........

想成為嵌入式程序員應知道的0x10個基本問題:
預處理器（Preprocessor）

* 1 . 用預處理指令#define 聲明一個常數，用以表明1年中有多少秒（忽略閏年問題）
         #define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL
我在這想看到幾件事情：
1) #define 語法的基本知識（例如：不能以分號結束，括號的使用，等等）
2)懂得預處理器將為你計算常數表達式的值，因此，直接寫出你是如何計算一年中有多少秒而不是計算出實際的值，是更清晰而沒有代價的。
3) 意識到這個表達式將使一個16位機的整型數溢出-因此要用到長整型符號L,告訴編譯器這個常數是的長整型數。
4) 如果你在你的表達式中用到UL（表示無符號長整型），那?你有了一個好的起點。記住，第一印象很重要。

* 2 . 寫一個"標準"宏MIN ，這個宏輸入兩個參數並返回較小的一個。
        #define MIN(A,B) （（A） <= (B) ? (A) : (B))
這個測試是為下面的目的而設的：
1) 標識#define在宏中應用的基本知識。這是很重要的。因為在  嵌入(inline)操作符 變為標準C的一部分之前，宏是方便產生嵌入代碼的唯一方法，對於嵌入式系統來說，為了能達到要求的性能，嵌入代碼經常是必須的方法。
2) 三重條件操作符的知識。這個操作符存在C語言中的原因是它使得編譯器能產生比if-then-else更優化的代碼，了解這個用法是很重要的。
3) 懂得在宏中小心地把參數用括號括起來
4) 我也用這個問題開始討論宏的副作用，例如：當你寫下面的代碼時會發生什?事？
        least = MIN(*p++, b);

* 3. 預處理器標識#error的目的是什?？
如果你不知道答案，請看參考文獻1。這問題對區分一個正常的夥計和一個書呆子是很有用
的。只有書呆子才會讀C語言課本的附錄去找出象這種問題的答案。當然如果你不是在找一
個書呆子，那?應試者最好希望自己不要知道答案。


死循環（Infinite loops）

* 4. 嵌入式系統中經常要用到無限循環，你怎?樣用C編寫死循環呢？
這個問題用幾個解決方案。我首選的方案是：

while(1)
{

}

一些程序員更喜歡如下方案：

for(;;)
{

}

這個實現方式讓我為難，因為這個語法沒有確切表達到底怎?回事。如果一個應試者給出這
個作為方案，我將用這個作為一個機會去探究他們這樣做的基本原理。如果他們的基本答案
是："我被教著這樣做，但從沒有想到過為什?。"這會給我留下一個壞印象。

第三個方案是用 goto
Loop:
...
goto Loop;
應試者如給出上面的方案，這說明或者他是一個匯編語言程序員（這也許是好事）或者他是一個想進入新領域的BASIC/FORTRAN程序員。


數據聲明（Data declarations）

* 5. 用變量a給出下面的定義
a) 一個整型數（An integer）
b)一個指向整型數的指針（ A pointer to an integer）
c)一個指向指針的的指針，它指向的指針是指向一個整型數（ A pointer to a pointer to an intege）r
d)一個有10個整型數的數組（ An array of 10 integers）
e) 一個有10個指針的數組，該指針是指向一個整型數的。（An array of 10 pointers to integers）
f) 一個指向有10個整型數數組的指針（ A pointer to an array of 10 integers）
g) 一個指向函數的指針，該函數有一個整型參數並返回一個整型數（A pointer to a function that takes an integer as an argument and returns an integer）
h) 一個有10個指針的數組，該指針指向一個函數，該函數有一個整型參數並返回一個整型數（ An array of ten pointers to functions that take an integer argument and return an integer ）

答案是：
a) int a; // An integer
b) int *a; // A pointer to an integer
c) int **a; // A pointer to a pointer to an integer
d) int a[10]; // An array of 10 integers
e) int *a[10]; // An array of 10 pointers to integers
f) int (*a)[10]; // A pointer to an array of 10 integers
g) int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer
h) int (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer

人們經常聲稱這裏有幾個問題是那種要翻一下書才能回答的問題，我同意這種說法。當我寫
這篇文章時，為了確定語法的正確性，我的確查了一下書。但是當我被面試的時候，我期望
被問到這個問題（或者相近的問題）。因為在被面試的這段時間裏，我確定我知道這個問題
的答案。應試者如果不知道所有的答案（或至少大部分答案），那?也就沒有為這次面試做
準備，如果該面試者沒有為這次面試做準備，那?他又能為什?出準備呢？

Static

* 6. 關鍵字static的作用是什?？
這個簡單的問題很少有人能回答完全。在C語言中，關鍵字static有三個明顯的作用：
1)在函數體，一個被聲明為靜態的變量在這一函數被調用過程中維持其值不變。
2) 在模塊內（但在函數體外），一個被聲明為靜態的變量可以被模塊內所用函數訪問，但不能被模塊外其它函數訪問。它是一個本地的全局變量。
3) 在模塊內，一個被聲明為靜態的函數只可被這一模塊內的其它函數調用。那就是，這個函數被限制在聲明它的模塊的本地範圍內使用。

大多數應試者能正確回答第一部分，一部分能正確回答第二部分，同是很少的人能懂得第三部分。這是一個應試者的嚴重的缺點，因為他顯然不懂得本地化數據和代碼範圍的好處和重要性。

Const

* 7．關鍵字const有什?含意？ - hard

我只要一聽到被面試者說："const意味著常數"，我就知道我正在和一個業余者打交道。去
年Dan Saks已經在他的文章裏完全概括了const的所有用法，因此ESP(譯者：Embedded
Systems Programming)的每一位讀者應該非常熟悉const能做什?和不能做什?.如果你從沒有
讀到那篇文章，只要能說出const意味著"只讀"就可以了。盡管這個答案不是完全的答案，
但我接受它作為一個正確的答案。（如果你想知道更詳細的答案，仔細讀一下Saks的文章
吧。）

如果應試者能正確回答這個問題，我將問他一個附加的問題：
下面的聲明都是什?意思？

const int a;
int const a;
const int *a;
int * const a;
int const * a const;

/******/
前兩個的作用是一樣，a是一個常整型數。第三個意味著a是一個指向常整型數的指針（也就是，整型數是不可修改的，但指針可以）。第四個意思a是一個指向整型數的常指針（也就是說，指針指向的整型數是可以修改的，但指針是不可修改的）。最後一個意味著a是一個指向常整型數的常指針（也就是說，指針指向的整型數是不可修改的，同時指針也是不可修改的）。如果應試者能正確回答這些問題，那?他就給我留下了一個好印象。順帶提一句，也許你可能會問，即使不用關鍵字 const，也還是能很容易寫出功能正確的程序，那?我為什?還要如此看重關鍵字const呢？我也如下的幾下理由：
1) 關鍵字const的作用是為給讀你代碼的人傳達非常有用的信息，實際上，聲明一個參數為常量是為了告訴了用戶這個參數的應用目的。如果你曾花很多時間清理其它人留下的垃圾，你就會很快學會感謝這點多余的信息。（當然，懂得用const的程序員很少會留下的垃圾讓別人來清理的。）
2) 通過給優化器一些附加的信息，使用關鍵字const也許能產生更緊湊的代碼。
3) 合理地使用關鍵字const可以使編譯器很自然地保護那些不希望被改變的參數，防止其被無意的代碼修改。簡而言之，這樣可以減少bug的出現。


Volatile

* 8. 關鍵字volatile有什?含意?並給出三個不同的例子。
一個定義為volatile的變量是說這變量可能會被意想不到地改變，這樣，編譯器就不會去假
設這個變量的值了。精確地說就是，優化器在用到這個變量時必須每次都小心地重新讀取這
個變量的值，而不是使用保存在寄存器裏的備份。下面是volatile變量的幾個例子：

1) 並行設備的硬件寄存器（如：狀態寄存器）
2) 一個中斷服務子程序中會訪問到的非自動變量(Non-automatic variables)
3) 多線程應用中被幾個任務共享的變量

回答不出這個問題的人是不會被雇傭的。我認為這是區分C程序員和嵌入式系統程序員的最基本的問題。搞嵌入式的家夥們經常同硬件、中斷、RTOS等等打交道，所有這些都要求用到volatile變量。不懂得volatile的內容將會帶來災難。
假設被面試者正確地回答了這是問題（嗯，懷疑是否會是這樣），我將稍微深究一下，看一下這家夥是不是直正懂得volatile完全的重要性。
1)一個參數既可以是const還可以是volatile嗎？解釋為什?。
2); 一個指針可以是volatile 嗎？解釋為什?。
3); 下面的函數有什?錯誤：

int square(volatile int *ptr)
{
        return *ptr * *ptr;
}

下面是答案：
1)是的。一個例子是只讀的狀態寄存器。它是volatile因為它可能被意想不到地改變。它是const因為程序不應該試圖去修改它。
2); 是的。盡管這並不很常見。一個例子是當一個中服務子程序修該一個指向一個buffer的指針時。
3) 這段代碼有點變態。這段代碼的目的是用來返指針*ptr指向值的平方，但是，由於*ptr指向一個volatile型參數，編譯器將產生類似下面的代碼：

int square(volatile int *ptr)
{
    int a,b;
    a = *ptr;
    b = *ptr;
    return a * b;
}

由於*ptr的值可能被意想不到地該變，因此a和b可能是不同的。結果，這段代碼可能返不是你所期望的平方值！正確的代碼如下：

long square(volatile int *ptr)
{
    int a;
    a = *ptr;
    return a * a;
}

位操作（Bit manipulation）

* 9. 嵌入式系統總是要用戶對變量或寄存器進行位操作。給定一個整型變量a，寫兩段代碼，
第一個設置a的bit 3，第二個清除a 的bit 3。在以上兩個操作中，要保持其它位不變。
對這個問題有三種基本的反應

1 不知道如何下手。該被面者從沒做過任何嵌入式系統的工作。

2 用bit fields。Bit fields是被扔到C語言死角的東西，它保證你的代碼在不同編譯器之
間是不可移植的，同時也保證了的你的代碼是不可重用的。我最近不幸看到 Infineon為其
較復雜的通信芯片寫的驅動程序，它用到了bit fields因此完全對我無用，因為我的編譯器
用其它的方式來實現bit fields的。從道德講：永遠不要讓一個非嵌入式的家夥粘實際硬件
的邊。

3 用 #defines 和 bit masks 操作。這是一個有極高可移植性的方法，是應該被用到的方
法。最佳的解決方案如下：

#define BIT3 (0x1 << 3)
static int a;

void set_bit3(void)
{
    a |= BIT3;
}
void clear_bit3(void)
{
    a &= ~BIT3;
}

一些人喜歡為設置和清除值而定義一個掩碼同時定義一些說明常數，這也是可以接受的。我希望看到幾個要點：說明常數、|=和&=~操作。


訪問固定的內存位置（Accessing fixed memory locations）

* 10. 嵌入式系統經常具有要求程序員去訪問某特定的內存位置的特點。

在某工程中，要求設置一絕對地址為0x67a9的整型變量的值為0xaa66。編譯器是一個純粹的
ANSI編譯器。寫代碼去完成這一任務。

這一問題測試你是否知道為了訪問一絕對地址把一個整型數強制轉換（typecast）為一指針
是合法的。這一問題的實現方式隨著個人風格不同而不同。典型的類似代碼如下：

    int *ptr;
    ptr = (int *)0x67a9;
    *ptr = 0xaa55;

 A more obscure approach is:
一個較晦澀的方法是：

    *(int * const)(0x67a9) = 0xaa55;

即使你的品味更接近第二種方案，但我建議你在面試時使用第一種方案。

中斷（Interrupts）

* 11. 中斷是嵌入式系統中重要的組成部分，
這導致了很多編譯開發商提供一種擴展—讓標準C支持中斷。具代表事實是，產生了一個新
的關鍵字 __interrupt。下面的代碼就使用了__interrupt關鍵字去定義了一個中斷服務子
程序(ISR)，請評論一下這段代碼的。

__interrupt double compute_area (double radius)
{
    double area = PI * radius * radius;
    printf("\nArea = %f", area);
    return area;
}

這個函數有太多的錯誤了，以至讓人不知從何說起了：

1 ISR 不能返回一個值。如果你不懂這個，那你不會被雇用的。

2 ISR 不能傳遞參數。如果你沒有看到這一點，你被雇用的機會等同第一項。

3 在許多的處理器/編譯器中，浮點一般都是不可重入的。有些處理器/編譯器需要讓額處的
寄存器入棧，有些處理器/編譯器就是不允許在ISR中做浮點運算。此外，ISR應該是短而有
效率的，在ISR中做浮點運算是不明智的。

4 與第三點一脈相承，printf()經常有重入和性能上的問題。如果你丟掉了第三和第四點，
我不會太為難你的。不用說，如果你能得到後兩點，那?你的被雇用前景越來越光明了。

代碼例子（Code examples）

* 12 . 下面的代碼輸出是什?，為什?？ - hard

void foo(void)
{
    unsigned int a = 6;
    int b = -20;
    (a+b > 6) ? puts("> 6") : puts("<= 6");
}

這個問題測試你是否懂得C語言中的整數自動轉換原則，我發現有些開發者懂得極少這些東
西。不管如何，這無符號整型問題的答案是輸出是 ">6"。原因是當表達式中存在有符號類
型和無符號類型時所有的操作數都自動轉換為無符號類型。因此-20變成了一個非常大的正
整數，所以該表達式計算出的結果大於6。這一點對於應當頻繁用到無符號數據類型的嵌入
式系統來說是豐常重要的。如果你答錯了這個問題，你也就到了得不到這份工作的邊緣。

* 13. 評價下面的代碼片斷：

unsigned int zero = 0;
unsigned int compzero = 0xFFFF;

/*1's complement of zero */

對於一個int型不是16位的處理器為說，上面的代碼是不正確的。應編寫如下：

unsigned int compzero = ~0;

這一問題真正能揭露出應試者是否懂得處理器字長的重要性。在我的經驗裏，好的嵌入式程
序員非常準確地明白硬件的細節和它的局限，然而PC機程序往往把硬件作為一個無法避免的
煩惱。

到了這個階段，應試者或者完全垂頭喪氣了或者信心滿滿誌在必得。如果顯然應試者不是很
好，那?這個測試就在這裏結束了。但如果顯然應試者做得不錯，那?我就扔出下面的追加問
題，這些問題是比較難的，我想僅僅非常優秀的應試者能做得不錯。提出這些問題，我希望
更多看到應試者應付問題的方法，而不是答案。不管如何，你就當是這個娛樂吧...

動態內存分配（Dynamic memory allocation）

* 14. 盡管不像非嵌入式計算機那? - hard
常見，嵌入式系統還是有從堆（heap）中動態分配內存的過程的。那?嵌入式系統中，動態分配內存可能發生的問題是什?？
這裏，我期望應試者能提到內存碎片，碎片收集的問題，變量的持行時間等等。這個主題已
經在ESP雜誌中被廣泛地討論過了（主要是 P.J. Plauger, 他的解釋遠遠超過我這裏能提到
的任何解釋），所有回過頭看一下這些雜誌吧！讓應試者進入一種虛假的安全感覺後，我拿
出這?一個小節目：

下面的代碼片段的輸出是什?，為什?？

char *ptr;
if ((ptr = (char *)malloc(0)) == NULL)
    puts("Got a null pointer");
else
    puts("Got a valid pointer");

這是一個有趣的問題。最近在我的一個同事不經意把0值傳給了函數malloc，得到了一個合
法的指針之後，我才想到這個問題。這就是上面的代碼，該代碼的輸出是"Got a valid
pointer"。我用這個來開始討論這樣的一問題，看看被面試者是否想到庫例程這樣做是正確。
得到正確的答案固然重要，但解決問題的方法和你做決定的基本原理更重要些。

Typedef
 
* 15 Typedef 在C語言中頻繁用以聲明一個已經存在的數據類型的同義字。也可以用預處理器做類似的事。例如，思考一下下面的例子：

#define dPS struct s *
typedef struct s * tPS;

以上兩種情況的意圖都是要定義dPS 和 tPS 作為一個指向結構s指針。哪種方法更好呢？（如果有的話）為什?？

這是一個非常微妙的問題，任何人答對這個問題（正當的原因）是應當被恭喜的。答案是：typedef更好。思考下面的例子：

dPS p1,p2;
tPS p3,p4;

第一個擴展為

struct s * p1, p2;
.
上面的代碼定義p1為一個指向結構的指，p2為一個實際的結構，這也許不是你想要的。第二個例子正確地定義了p3 和p4 兩個指針。晦澀的語法

* 16 . C語言同意一些令人震驚的結構,下面的結構是合法的嗎，如果是它做些什?？

int a = 5, b = 7, c;

c = a+++b;

這個問題將做為這個測驗的一個愉快的結尾。不管你相不相信，上面的例子是完全合乎語法
的。問題是編譯器如何處理它？水平不高的編譯作者實際上會爭論這個問題，根據最處理原
則，編譯器應當能處理盡可能所有合法的用法。因此，上面的代碼被處理成：

c = a++ + b;

因此, 這段代碼持行後a = 6, b = 7, c = 12。

如果你知道答案，或猜出正確答案，做得好。如果你不知道答案，我也不把這個當作問題。
我發現這個問題的最大好處是這是一個關於代碼編寫風格，代碼的可讀性，代碼的可修改性
的好的話題。
